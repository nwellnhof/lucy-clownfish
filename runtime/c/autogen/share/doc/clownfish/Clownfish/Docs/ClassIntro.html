<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
***********************************************

!!!! DO NOT EDIT !!!!

This file was auto-generated by cfc.

***********************************************

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<meta name="viewport" content="width=device-width" />
<title>Clownfish::Docs::ClassIntro</title>
<style type="text/css">
body {
    max-width: 48em;
    font: 0.85em/1.4 sans-serif;
}
a {
    color: #23b;
}
table {
    border-collapse: collapse;
}
td {
    padding: 0;
}
td.label {
    padding-right: 2em;
    font-weight: bold;
}
dt {
    font-weight: bold;
}
pre {
    border: 1px solid #ccc;
    padding: 0.2em 0.4em;
    background: #f6f6f6;
    font-size: 0.92em;
}
pre a {
    text-decoration: none;
}
pre, code {
    font-family: "Consolas", "Menlo", monospace;
}
span.prefix, span.comment {
    color: #888;
}
</style>
</head>
<body>
<h1>Working with Apache Clownfish classes in C</h1>
<h2>Inititalizing Clownfish parcels</h2>
<p>Every Clownfish parcel must be initialized before it is used. The
initialization function is named <code>{parcel_nick}_bootstrap_parcel</code> and
takes no arguments.</p>
<p>Example:</p>
<pre><code>cfish_bootstrap_parcel();
</code></pre>
<h2>Including the generated header file</h2>
<p>To use Clownfish classes from C code, the header file generated by the
Clownfish compiler must be included. The name of the C header is
derived from the name of the Clownfish <code>.cfh</code> header. It can also be
found in the class documentation.</p>
<p>Typically, the “short name macro” should be defined before including a
Clownfish header. Its name is derived from the parcel nickname and has
the form <code>{PARCEL_NICK}_USE_SHORT_NAMES</code>. If the short name macro is in
effect, you don’t have to worry about parcel prefixes.</p>
<p>Example:</p>
<pre><code>#define CFISH_USE_SHORT_NAMES

#include &lt;Clownfish/String.h&gt;
#include &lt;Clownfish/Vector.h&gt;
</code></pre>
<h2>Function and method prefixes</h2>
<p>Clownfish classes can have a “nickname” – a shorter version of the
class name that is used for function and method prefixes. The nickname
can be found in the class documentation.</p>
<p>For example the String class has the nickname <code>Str</code>.</p>
<h2>Creating objects</h2>
<p>A Clownfish object is a pointer to an opaque struct.</p>
<p>Most classes come with one or more constructors. On the C level, a
constructor is simply an “inert” function of a class that returns a
new object. In Clownfish parlance, an inert function is any function
in a class that isn’t a method, similar to static methods in Java or
static member functions in C++.</p>
<p>Example:</p>
<pre><code>// Notice the use of nickname &quot;Str&quot; in the constructor prefix.
String *name = Str_newf(&quot;%s %s&quot;, first, last);
</code></pre>
<h2>Calling methods</h2>
<p>Calling methods is straight-forward. The invocant is always passed as
first argument.</p>
<pre><code>// Notice the use of nickname &quot;Str&quot; in the method prefix.
size_t len = Str_Length(name);
</code></pre>
<p>Method names always start with an uppercase letter.</p>
<h2>Memory management</h2>
<p>Clownfish uses reference counting to manage memory. Constructors, but
also some methods, return an “incremented” object. If you’re done with
an incremented object, you must decrease its reference count to avoid
leaking memory. Use the <code>DECREF</code> macro to release an object:</p>
<pre><code>DECREF(name);
</code></pre>
<p>Some other methods return non-incremented objects. If you want to retain
a reference to such an object, you must increase its reference count
using the <code>INCREF</code> macro to make sure it won’t be destroyed too early:</p>
<pre><code>obj = INCREF(obj);
</code></pre>
<p>This invocation of INCREF must be matched by a DECREF when you’re done
with the object.</p>
<p>Some methods, for example in container classes, take “decremented”
objects as arguments. From the caller’s perspective, passing a
decremented argument is equivalent to passing a non-decremented argument
and calling DECREF afterwards. Typically, this avoids a call to DECREF
in the calling code. But sometimes, it must be compensated with an
INCREF.</p>
<h2>Further reading</h2>
<ul>
<li><a href="../../Clownfish/Docs/BuildingProjects.html">Building Clownfish projects in C environments</a></li>
<li><a href="../../Clownfish/Docs/WritingClasses.html">Writing Clownfish classes</a></li>
</ul>
</body>
</html>
