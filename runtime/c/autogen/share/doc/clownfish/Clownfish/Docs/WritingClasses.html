<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<!--
***********************************************

!!!! DO NOT EDIT !!!!

This file was auto-generated by cfc.

***********************************************

Licensed to the Apache Software Foundation (ASF) under one or more
contributor license agreements.  See the NOTICE file distributed with
this work for additional information regarding copyright ownership.
The ASF licenses this file to You under the Apache License, Version 2.0
(the "License"); you may not use this file except in compliance with
the License.  You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->
<meta name="viewport" content="width=device-width" />
<title>Clownfish::Docs::WritingClasses</title>
<style type="text/css">
body {
    max-width: 48em;
    font: 0.85em/1.4 sans-serif;
}
a {
    color: #23b;
}
table {
    border-collapse: collapse;
}
td {
    padding: 0;
}
td.label {
    padding-right: 2em;
    font-weight: bold;
}
dt {
    font-weight: bold;
}
pre {
    border: 1px solid #ccc;
    padding: 0.2em 0.4em;
    background: #f6f6f6;
    font-size: 0.92em;
}
pre a {
    text-decoration: none;
}
pre, code {
    font-family: "Consolas", "Menlo", monospace;
}
span.prefix, span.comment {
    color: #888;
}
</style>
</head>
<body>
<h1>Writing Apache Clownfish classes</h1>
<h2>Parcels</h2>
<p>Every Clownfish class belongs to a Clownfish parcel. Parcels are used for
namespacing and versioning. Information about parcels is stored in <code>.cfp</code>
files which contain a JSON hash with the following keys:</p>
<ul>
<li>
<p><strong>name:</strong> The parcel’s name. It must contain only letters.</p>
</li>
<li>
<p><strong>nickname:</strong> A short nickname. It must contain only letters. This nickname,
followed by an underscore, is used to prefix generated C symbols and
macros. Depending on the kind of symbol, a lowercase, mixed case, or
uppercase prefix will be used.</p>
</li>
<li>
<p><strong>version:</strong> A version specifier of the following form (without whitespace):</p>
<pre><code>version-specifier = &quot;v&quot; version-number
version-number = digit | digit &quot;.&quot; version-number
</code></pre>
</li>
<li>
<p><strong>prerequisites:</strong> A hash containing the prerequisite parcels. The hash keys
are the parcel names. The values contain the minimum required version.</p>
</li>
</ul>
<p>An example <code>.cfp</code> file might look like:</p>
<pre><code>{
    &quot;name&quot;: &quot;Pathfinder&quot;,
    &quot;nickname&quot;: &quot;Pfind&quot;,
    &quot;version&quot;: &quot;v2.3.8&quot;,
    &quot;prerequisites&quot;: {
        &quot;Clownfish&quot;: &quot;v0.4.0&quot;
    }
}
</code></pre>
<p>A parcel specifier of the following form is used in Clownfish header files:</p>
<pre><code>parcel-specifier = &quot;parcel&quot; parcel-name &quot;;&quot;
parcel-name = identifier
</code></pre>
<p>For example:</p>
<pre><code>parcel Pathfinder;
</code></pre>
<p>Every <code>.cfh</code> file starts with a parcel specifier containing the name of
the parcel for all classes in the header file.</p>
<h3>Initialization</h3>
<p>Every Clownfish parcel must be initialized before it is used. The
initialization function is named <code>{parcel_nick}_bootstrap_parcel</code> and takes
no arguments.</p>
<p>Example call:</p>
<pre><code>pfind_bootstrap_parcel();
</code></pre>
<p>The generated host language bindings call the bootstrap function
automatically. C projects must call the function manually.</p>
<h3>Short names</h3>
<p>If a macro with the uppercase name <code>{PARCEL_NICK}_USE_SHORT_NAMES</code> is
defined before including a generated C header, additional macros without the
parcel prefix will be defined for most symbols.</p>
<p>Example:</p>
<pre><code>#define PFIND_USE_SHORT_NAMES
#include &lt;Pathfinder/Graph.h&gt;
#include &lt;Pathfinder/Path.h&gt;

/* Prefixes can be omitted. */
Path *path = Graph_Find_Shortest_Path(graph);

/* Without PFIND_USE_SHORT_NAMES, one would have to write: */
pfind_Path *path = PFIND_Graph_Find_Shortest_Path(graph);
</code></pre>
<p>For object types in Clownfish header files, prefixes of class structs can
also be omitted unless multiple parcels declare classes with the same last
component of the class name.</p>
<h3>The “Clownfish” parcel</h3>
<p>The Clownfish runtime classes live in a parcel named <code>Clownfish</code> with
nickname <code>Cfish</code>. Consequently, the short name macro is named
<code>CFISH_USE_SHORT_NAMES</code>.</p>
<h2>Declaring classes</h2>
<p>Classes are declared in Clownfish header files using a declaration of the
following form:</p>
<pre><code>class-declaration = class-exposure-specifier?
                    class-modifier*
                    &quot;class&quot; class-name
                    (&quot;nickname&quot; class-nickname)?
                    (&quot;inherits&quot; class-name)?
                    &quot;{&quot; class-contents &quot;}&quot;
class-exposure-specifier = &quot;public&quot;
class-modifier = &quot;inert&quot; | &quot;final&quot;
class-name = identifier | identifier &quot;::&quot; class-name
class-nickname = identifier
class-contents = (variable-declaration | function-declaration)*
</code></pre>
<p>Class name components must start with an uppercase letter and must not contain
underscores. The last component must contain at least one lowercase letter and
must be unique for every class in a parcel.</p>
<p>For every class, a type with the name <code>{parcel_nick}_{Class_Last_Comp}</code>
is defined in the generated C header. This is an opaque typedef used to
ensure type safety.</p>
<p>For every class, a global variable with the uppercase name
<code>{PARCEL_NICK}_{CLASS_LAST_COMP}</code> is defined. This variable is a pointer to
a Clownfish::Class object which is initialized when bootstrapping the parcel.</p>
<p>Non-inert classes inherit from Clownfish::Obj by default.</p>
<p>Example of a class declaration:</p>
<pre><code>parcel Pathfinder;

public class Pathfinder::Graph::VisibilityGraph nickname VisGraph
    extends Clownfish::Obj {
    /* Variables and functions */
}
</code></pre>
<p>This will generate:</p>
<pre><code>typedef struct pfind_VisibilityGraph pfind_VisibilityGraph;
extern cfish_Class *PFIND_VISIBILITYGRAPH;
</code></pre>
<h3>Class exposure</h3>
<p>TODO</p>
<h3>Inert classes</h3>
<p>Inert classes must contain only inert variables or inert functions, that is,
neither instance variables nor methods. They must not inherit from another
class or be inherited from. They’re essentially nothing more than a
namespace for functions and global variables.</p>
<h3>Final classes</h3>
<p>For final classes, every method is made final, regardless of the method
modifier. Final classes must not be inherited from.</p>
<h2>Variables</h2>
<p>Variables are declared with a declaration of the following form:</p>
<pre><code>variable-declaration = variable-exposure-specifier?
                       variable-modifier*
                       type variable-name &quot;;&quot;
variable-exposure-specifier = &quot;public&quot;
variable-modifier = &quot;inert&quot;
variable-name = identifier
</code></pre>
<h3>Inert variables</h3>
<p>Inert variables are global class variables of which only a single copy
exists. They are declared in the generated C header with the name
<code>{parcel_nick}_{Class_Nick}_{Variable_Name}</code> and must be defined in a C
source file.</p>
<p>Example:</p>
<pre><code>public class Pathfinder::Path {
    public inert int max_path_length;
}
</code></pre>
<p>This will generate:</p>
<pre><code>extern int pfind_Path_max_path_length;
</code></pre>
<p>The C source file defining the variable will typically use short names. So the
definition will look like:</p>
<pre><code>int Path_max_path_length = 5000;
</code></pre>
<h3>Inert variable exposure</h3>
<p>TODO</p>
<h3>Instance variables</h3>
<p>Non-inert variables are instance variables and added to the class’s ivars
struct. They must not have an exposure specifier.</p>
<p>Example:</p>
<pre><code>public class Pathfinder::Path {
    int num_nodes;

    public int
    Get_Num_Nodes(Path *self);
}
</code></pre>
<p>This will add a <code>num_nodes</code> member to the ivars struct of <code>Path</code>.</p>
<h3>The ivars struct</h3>
<p>To access instance variables, the macro <code>C_{PARCEL_NICK}_{CLASS_LAST_COMP}</code>
must be defined before including the generated header file. This will make
a struct named <code>{parcel_nick}_{Class_Name}IVARS</code> with a corresponding
typedef and short name available that contains all instance variables
of the class and all superclasses from the same parcel. Instance
variables defined in other parcels are not accessible. This is by
design to guarantee ABI stability if the instance variable layout
of a superclass from another parcel changes in a different version.
If you need to access an instance variable from another parcel,
add accessor methods.</p>
<p>A pointer to the ivars struct can be obtained by calling an inline
function named <code>{parcel_nick}_{Class_Name}_IVARS</code>. This function
takes the object of the class (typically <code>self</code>) as argument.</p>
<p>Example using short names:</p>
<pre><code>#define C_PFIND_PATH
#define PFIND_USE_SHORT_NAMES
#include &quot;Pathfinder/Path.h&quot;

int
Path_get_num_nodes(Path *self) {
    PathIVARS *ivars = Path_IVARS(self);
    return ivars-&gt;num_nodes;
}
</code></pre>
<h2>Functions</h2>
<pre><code>function-declaration = function-exposure-specifier?
                       function-modifier*
                       return-type function-name
                       &quot;(&quot; param-list? &quot;)&quot; &quot;;&quot;
function-exposure-specifier = &quot;public&quot;
function-modifier = &quot;inert&quot; | &quot;inline&quot; | &quot;abstract&quot; | &quot;final&quot;
return-type = return-type-qualifier* type
return-type-qualifier = &quot;incremented&quot; | &quot;nullable&quot;
function-name = identifier
param-list = param | param &quot;,&quot; param-list
param = param-qualifier* type param-name (&quot;=&quot; scalar-constant)?
param-name = identifier
param-qualifier = &quot;decremented&quot;
</code></pre>
<h3>Function exposure</h3>
<p>TODO</p>
<h3>Inert functions</h3>
<p>Inert functions are dispatched statically. They are declared in the generated
C header with the name <code>{parcel_nick}_{Class_Nick}_{Function_Name}</code>
and must be defined in a C source file. They must be neither abstract nor
final.</p>
<p>Example:</p>
<pre><code>public class Pathfinder::Graph::VisibilityGraph nickname VisGraph
    extends Clownfish::Obj {

    public inert incremented VisibilityGraph*
    new(int node_capacity);
}
</code></pre>
<p>This will generate:</p>
<pre><code>pfind_VisibilityGraph*
pfind_VisGraph_new(int node_capacity);
</code></pre>
<p>The C source file implementing the inert function will typically use short
names. So the implementation will look like:</p>
<pre><code>#define PFIND_USE_SHORT_NAMES
#include &quot;Pathfinder/Graph/VisibilityGraph.h&quot;

VisibilityGraph*
VisGraph_new(int node_capacity) {
    /* Implementation */
}
</code></pre>
<h3>Inline functions</h3>
<p>Inert functions can be inline. They should be defined as static inline
functions in a C block in the Clownfish header file. The macro <code>CFISH_INLINE</code>
expands to the C compiler’s inline keyword and should be used for portability.</p>
<h3>Methods</h3>
<p>Non-inert functions are dynamically dispatched methods. Their name must start
with an uppercase letter and every underscore must be followed by an uppercase
letter. Methods must not be declared inline.</p>
<p>The first parameter of a method must be a pointer to an object of the method’s
class which receives the object on which the method was invoked. By convention,
this parameter is named <code>self</code>.</p>
<p>For every method, an inline wrapper for dynamic dispatch is defined in
the generated C header with the name
<code>{PARCEL_NICK}_{Class_Nick}_{Method_Name}</code>. Additionally, an
implementing function is declared with the name
<code>{PARCEL_NICK}_{Class_Nick}_{Method_Name}_IMP</code>. The Clownfish compiler also
generates a typedef for the method’s function pointer type named
<code>{PARCEL_NICK}_{Class_Nick}_{Method_Name}_t</code>. Wrappers and typedefs are
created for all subclasses whether they override a method or not.</p>
<p>Example:</p>
<pre><code>public class Pathfinder::Graph::VisibilityGraph nickname VisGraph
    extends Clownfish::Obj {

    public void
    Add_Node(VisibilityGraph *self, decremented Node *node);
}
</code></pre>
<p>This will generate:</p>
<pre><code>/* Wrapper for dynamic dispatch */
static inline void
PFIND_VisGraph_Add_Node(pfind_VisibilityGraph *self, pfind_Node *node) {
    /* Inline code for wrapper */
}

/* Declaration of implementing function */
void
PFIND_VisGraph_Add_Node_IMP(pfind_VisibilityGraph *self,
                            pfind_Node *node);

/* Declaration of function pointer type */
typedef void
(*PFIND_VisGraph_Add_Node_t)(pfind_VisibilityGraph *self,
                             pfind_Node *node);
</code></pre>
<p>The implementing function of non-abstract methods must be defined in a C source
file. This file will typically define the short names macro. So the
implementation will look like:</p>
<pre><code>#define PFIND_USE_SHORT_NAMES
#include &quot;Pathfinder/Graph/VisibilityGraph.h&quot;

void
VisGraph_Add_Node_IMP(VisibilityGraph *self, Node *node) {
    /* Implementation */
}
</code></pre>
<h3>Looking up function pointers</h3>
<p>Clownfish defines a macro named <code>CFISH_METHOD_PTR</code> that looks up the pointer
to the implementing function of a method. The first parameter of the macro is
a pointer to the Clownfish::Class object of the method’s class, the second is
the unshortened name of the method wrapper. If short names for the Clownfish
parcel are used, the macro is also available under the name <code>METHOD_PTR</code>.</p>
<p>To lookup methods from a superclass, there’s a macro <code>CFISH_SUPER_METHOD_PTR</code>
with the same parameters.</p>
<p>Example using short names:</p>
<pre><code>VisGraph_Add_Node_t add_node
    = METHOD_PTR(PFIND_VISIBILITYGRAPH, Pfind_VisGraph_Add_Node);

VisGraph_Add_Node_t super_add_node
    = SUPER_METHOD_PTR(PFIND_VISIBILITYGRAPH, Pfind_VisGraph_Add_Node);
</code></pre>
<h3>Abstract methods</h3>
<p>For abstract methods, the Clownfish compiler generates an implementing function
which throws an error. They should be overridden in a subclass.</p>
<h3>Final methods</h3>
<p>Final methods must not be overridden. They must not be abstract.</p>
<h3>Nullable return type</h3>
<p>If a function has a nullable return type, it must return a pointer.
Non-nullable functions must never return the NULL pointer.</p>
<h3>Incremented return type</h3>
<p>Incremented return types must be pointers to Clownfish objects. The function
will either return a new object with an initial reference count of 1 or
increment the reference count. The caller must decrement the reference count of
the returned object when it’s no longer used.</p>
<p>For returned objects with non-incremented return type, usually no additional
handling of reference counts is required. Only if an object is returned from an
accessor or a container object and the caller wants to use the object longer
than the returning object retains a reference, it must increment the reference
count itself and decrement when the object is no longer used.</p>
<h3>Decremented parameters</h3>
<p>Decremented parameters must be pointers to Clownfish objects. The function
will either decrement the reference count of the passed-in object or retain a
reference without incrementing the reference count. If the caller wants to use
the passed-in object afterwards, it usually must increment its reference count
before the call and decrement it when it’s no longer used. If the caller does
not make further use of the passed-in object, it must not decrement its
reference count after the call.</p>
<p>This is typically used in container classes like Vector:</p>
<pre><code>String *string = String_newf(&quot;Hello&quot;);
Vec_Push(array, (Obj*)string);
// No need to DECREF the string.
</code></pre>
<h3>Default parameter values</h3>
<p>Default parameter values can be given as integer, float, or string literals.
The values <code>true</code>, <code>false</code>, and <code>NULL</code> are also supported. The default
values are only used by the host language bindings. They’re not supported
when calling a function from C.</p>
<h2>C blocks</h2>
<p>Clownfish headers can contain C blocks which start with a line containing the
string <code>__C__</code> and end on a line containing the string <code>__END_C__</code>. The
contents of a C block are copied verbatim to the generated C header.</p>
<p>Example:</p>
<pre><code>__C__

struct pfind_AuxiliaryStruct {
    int a;
    int b;
};

__END_C__
</code></pre>
<h2>Object life cycle</h2>
<h3>Object creation</h3>
<p>Objects are allocated by invoking the <code>Make_Obj</code> method on a class’s
Clownfish::Class object.</p>
<p>Any inert function can be used to construct objects from C. But to support
inheritance and object creation from the host language, Clownfish classes
need a separate function to initialize objects. The initializer must take a
pointer to an object as first argument and return a pointer to the same
object. If the parent class has an initializer, it should be called first by
the subclass’s initializer.</p>
<p>By convention, the standard constructor is named <code>new</code>. If a class has an
inert function named <code>init</code>, it is used as initializer to create a host
language constructor by default.</p>
<p>Example:</p>
<pre><code>/* Clownfish header */

class Vehicle {
    double max_speed;

    inert Vehicle*
    init(Vehicle *self, double max_speed);
}

class Train inherits Vehicle {
    double track_gauge;

    inert incremented Train*
    new(double max_speed, double track_gauge);

    inert Train*
    init(Train *self, double max_speed, double track_gauge);
}

/* Implementation */

Train*
Train_new(double max_speed, double track_gauge) {
    Train *self = (Train*)Class_Make_Obj(TRAIN);
    return Train_init(self, max_speed, track_gauge);
}

Train*
Train_init(Train *self, double max_speed, double track_gauge) {
    Vehicle_init((Vehicle*)self, max_speed);
    self-&gt;track_gauge = track_gauge;
    return self;
}
</code></pre>
<h3>Reference counting</h3>
<p>Clownfish uses reference counting for memory management. Objects are created
with a reference count of 1. There are two macros <code>CFISH_INCREF</code> and
<code>CFISH_DECREF</code> to increment and decrement reference counts. If short names
for the Clownfish parcel are enabled, the macros can be abbreviated to
<code>INCREF</code> and <code>DECREF</code>. Both macros take a pointer to an object as argument.
NULL pointers are allowed. <code>CFISH_INCREF</code> returns a pointer to the object.
This value might differ from the passed-in pointer in some cases. So if a
reference is retained, the pointer returned from <code>CFISH_INCREF</code> should be
used. <code>CFISH_DECREF</code> returns the modified reference count.</p>
<p>Examples:</p>
<pre><code>self-&gt;value = INCREF(arg);

DECREF(object);
</code></pre>
<h3>Object destruction</h3>
<p>If an object’s reference count reaches 0, its <code>Destroy</code> method is called.
This public method takes no arguments besides <code>self</code> and has no return value.
It should release the resources held by the object and finally call the
<code>Destroy</code> method of the superclass via the <code>CFISH_SUPER_DESTROY</code> macro with
short name <code>SUPER_DESTROY</code>. This macro takes the <code>self</code> pointer as first
argument and a pointer to the object’s Clownfish::Class as second argument.
The <code>Destroy</code> method of the Clownfish::Obj class will eventually free the
object struct.</p>
<p>Example:</p>
<pre><code>/* Clownfish header */

class Path {
    Vector *nodes;

    public void
    Destroy(Path *self);
}

/* Implementation */

void
Path_Destroy_IMP(Path *self) {
    DECREF(self-&gt;nodes);
    SUPER_DESTROY(self, PATH);
}
</code></pre>
</body>
</html>
